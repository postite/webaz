<?php
/**
 * Generated by Haxe 4.0.0-rc.1+1fdd3d5
 * Haxe source file: /Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx
 */

namespace geojson\_Polygon;

use \tink\json\_Representation\Representation_Impl_;
use \php\_Boot\HxAnon;
use \php\Boot;
use \php\_Boot\HxException;

final class Polygon_Impl_ {

	/**
	 * @param \Array_hx $lines
	 * 
	 * @return object
	 */
	static public function _new ($lines) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:11: character 2
		$this1 = new HxAnon([
			"type" => "Polygon",
			"coordinates" => $lines,
		]);
		return $this1;
	}

	/**
	 * Determines if a point is contained in this polygon.
	 * Reference: http://geospatialpython.com/2011/01/point-in-polygon.html
	 * TODO: does this work if the polygon spans across the +/- boundary (e.g. the north/south poles or equator)?
	 * @param point the point to check
	 * @return true if this polygon contains the given point
	 * 
	 * @param object $this
	 * @param \Array_hx $point
	 * 
	 * @return bool
	 */
	static public function containsPoint ($this1, $point) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:57: lines 57-81
		$_contains = function ($point1, $line) {
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:58: characters 4-28
			$n = $line->length - 1;
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:59: characters 4-23
			$result = false;
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:60: characters 4-32
			$lat1 = (($line->arr[0] ?? null)->arr[1] ?? null);
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:61: characters 4-34
			$long1 = (($line->arr[0] ?? null)->arr[0] ?? null);
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:62: characters 4-42
			$longints = \Math::$NEGATIVE_INFINITY;
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:63: lines 63-79
			$_g = 0;
			$_g1 = $n + 1;
			while ($_g < $_g1) {
				$i = $_g++;
				#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:64: characters 5-31
				$current = ($line->arr[$i % $n] ?? null);
				#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:65: characters 5-33
				$lat2 = ($current->arr[1] ?? null);
				#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:66: characters 5-35
				$long2 = ($current->arr[0] ?? null);
				#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:67: lines 67-76
				if (($point1->arr[1] ?? null) > ((is_nan($lat1) || is_nan($lat2) ? \Math::$NaN : min($lat1, $lat2)))) {
					#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:68: lines 68-75
					if (($point1->arr[1] ?? null) <= ((is_nan($lat1) || is_nan($lat2) ? \Math::$NaN : max($lat1, $lat2)))) {
						#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:69: lines 69-74
						if (($point1->arr[0] ?? null) <= ((is_nan($long1) || is_nan($long2) ? \Math::$NaN : max($long1, $long2)))) {
							#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:70: lines 70-71
							if (!Boot::equal($lat1, $lat2)) {
								#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:71: characters 8-84
								$longints = (($point1->arr[1] ?? null) - $lat1) * ($long2 - $long1) / ($lat2 - $lat1) + $long1;
							}
							#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:72: lines 72-73
							if (Boot::equal($long1, $long2) || (($point1->arr[0] ?? null) <= $longints)) {
								#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:73: characters 8-24
								$result = !$result;
							}
						}
					}
				}
				#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:77: characters 5-16
				$lat1 = $lat2;
				#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:78: characters 5-18
				$long1 = $long2;
			}

			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:80: characters 4-17
			return $result;
		};
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:84: characters 3-47
		if (!$_contains($point, ($this1->coordinates->arr[0] ?? null))) {
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:84: characters 35-47
			return false;
		}
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:86: characters 3-73
		$_g2 = 1;
		$_g11 = $this1->coordinates->length;
		while ($_g2 < $_g11) {
			$i1 = $_g2++;
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:86: characters 30-73
			if ($_contains($point, ($this1->coordinates->arr[$i1] ?? null))) {
				#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:86: characters 61-73
				return false;
			}
		}

		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:87: characters 3-14
		return true;
	}

	/**
	 * @param object $rep
	 * 
	 * @return object
	 */
	static public function fromRepresentation ($rep) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:103: characters 10-19
		$_g = Representation_Impl_::get($rep);
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:104: lines 104-105
		if ($_g->type === "Polygon") {
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:104: characters 36-49
			return $_g;
		} else {
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:105: characters 13-18
			throw new HxException("Invalid Polygon");
		}
	}

	/**
	 * @param object $this
	 * 
	 * @return \Array_hx
	 */
	static public function get_lines ($this1) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:90: characters 30-53
		return $this1->coordinates;
	}

	/**
	 * @param object $this
	 * 
	 * @return string
	 */
	static public function get_type ($this1) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:92: characters 29-45
		return $this1->type;
	}

	/**
	 * Construct a regular polygon
	 * @param center center of the Polygon
	 * @param sides number of sides of the polygon
	 * @param radius radius of the polygon, normalized against the sphere's radius. For the Earth, use X(km) / 6378.1 (the Earth has mean radius of 6371km)
	 * @param bearing the starting bearing in degrees, default 0
	 * Example:
	 * The following code constructs a hexagon of radius 10km centered somewhere in Asia
	 * `regular([114.153775, 22.413735], 6, 10 / 6371)`
	 * 
	 * @param \Array_hx $center
	 * @param int $sides
	 * @param float $radius
	 * @param float $bearingOffset
	 * 
	 * @return object
	 */
	static public function regular ($center, $sides, $radius, $bearingOffset = 0) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:28: lines 28-46
		if ($bearingOffset === null) {
			$bearingOffset = 0;
		}
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:29: characters 3-42
		$lat = ($center->arr[1] ?? null) * 0.0174532925199444439;
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:30: characters 3-44
		$long = ($center->arr[0] ?? null) * 0.0174532925199444439;
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:31: characters 3-30
		$sinLat = sin($lat);
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:32: characters 3-30
		$cosLat = cos($lat);
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:33: characters 3-36
		$sinRadius = sin($radius);
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:34: characters 3-36
		$cosRadius = cos($radius);
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:35: characters 3-30
		$bearingOffset *= 0.0174532925199444439;
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:37: lines 37-43
		$_g = new \Array_hx();
		$_g1 = 0;
		while ($_g1 < $sides) {
			$n = $_g1++;
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:38: characters 4-64
			$bearing = 6.28318530718 / $sides * $n + $bearingOffset;
			#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:39: lines 39-42
			$latitude = asin($sinLat * $cosRadius + $cosLat * $sinRadius * cos($bearing)) * 57.2957795130785499;
			$this1 = \Array_hx::wrap([
				($long + atan2(sin($bearing) * $sinRadius * $cosLat, $cosRadius - $sinLat * $sinLat)) * 57.2957795130785499,
				$latitude,
			]);
			$_g->arr[$_g->length] = $this1;
			++$_g->length;

		}

		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:44: characters 3-25
		$_g->arr[$_g->length] = ($_g->arr[0] ?? null);
		++$_g->length;

		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:45: characters 10-31
		$this2 = new HxAnon([
			"type" => "Polygon",
			"coordinates" => \Array_hx::wrap([$_g]),
		]);
		return $this2;
	}

	/**
	 * @param object $this
	 * @param \Array_hx $v
	 * 
	 * @return \Array_hx
	 */
	static public function set_lines ($this1, $v) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:91: characters 31-58
		return $this1->coordinates = $v;
	}

	/**
	 * @param object $this
	 * 
	 * @return object
	 */
	static public function toGeoJson ($this1) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:93: characters 44-60
		return $this1;
	}

	/**
	 * @param object $this
	 * 
	 * @return object
	 */
	static public function toRepresentation ($this1) {
		#/Users/ut/haxe/haxe_libraries/geojson/0.9.7/haxelib/src/geojson/Polygon.hx:98: characters 10-49
		$this2 = $this1;
		return $this2;
	}
}

Boot::registerClass(Polygon_Impl_::class, 'geojson._Polygon.Polygon_Impl_');
Boot::registerGetters('geojson\\_Polygon\\Polygon_Impl_', [
	'type' => true,
	'lines' => true
]);
Boot::registerSetters('geojson\\_Polygon\\Polygon_Impl_', [
	'lines' => true
]);
