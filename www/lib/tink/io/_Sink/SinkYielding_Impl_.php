<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e1
 * Haxe source file: /Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx
 */

namespace tink\io\_Sink;

use \php\_Boot\HxAnon;
use \tink\core\_Future\SyncFuture;
use \tink\io\SinkObject;
use \php\Boot;
use \haxe\io\Output;
use \tink\io\_Source\Source_Impl_;
use \tink\core\TypedError;
use \tink\io\_Worker\Worker_Impl_;
use \tink\core\Outcome;
use \tink\io\std\OutputSink;
use \tink\core\_Lazy\LazyConst;
use \tink\core\_Future\FutureObject;

final class SinkYielding_Impl_ {
	/**
	 * @var SinkObject
	 */
	static public $BLACKHOLE;

	/**
	 * @param SinkObject $this
	 * 
	 * @return SinkObject
	 */
	static public function dirty ($this1) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:30: characters 5-21
		return $this1;
	}

	/**
	 * @param SinkObject $this
	 * 
	 * @return FutureObject
	 */
	static public function end ($this1) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:23: lines 23-27
		if ($this1->get_sealed()) {
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:23: characters 24-29
			return new SyncFuture(new LazyConst(Outcome::Success(false)));
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:24: lines 24-27
			$ret = $this1->consume(Source_Impl_::$EMPTY, new HxAnon(["end" => true]))->map(function ($r) {
				$__hx__switch = ($r->index);
				if ($__hx__switch === 0 || $__hx__switch === 1) {
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:25: characters 41-54
					return Outcome::Success(true);
				} else if ($__hx__switch === 2) {
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:26: characters 25-26
					$e = $r->params[0];
					#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:26: characters 32-42
					return Outcome::Failure($e);
				}
			});
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:24: lines 24-27
			return $ret->gather();
		}
	}

	/**
	 * @param TypedError $e
	 * 
	 * @return SinkObject
	 */
	static public function ofError ($e) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:33: characters 5-28
		return new ErrorSink($e);
	}

	/**
	 * @param string $name
	 * @param Output $target
	 * @param object $options
	 * 
	 * @return SinkObject
	 */
	static public function ofOutput ($name, $target, $options = null) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:52: lines 52-55
		$tmp = null;
		if ($options === null) {
			$tmp = Worker_Impl_::get();
		} else if ($options->worker === null) {
			$tmp = Worker_Impl_::get();
		} else {
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:54: characters 22-23
			$w = $options->worker;
			#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:52: lines 52-55
			$tmp = $w;
		}
		return new OutputSink($name, $target, $tmp);
	}

	/**
	 * @param FutureObject $p
	 * 
	 * @return SinkObject
	 */
	static public function ofPromised ($p) {
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:36: lines 36-39
		$ret = $p->map(function ($o) {
			$__hx__switch = ($o->index);
			if ($__hx__switch === 0) {
				#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:37: characters 20-21
				$v = $o->params[0];
				#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:37: characters 24-25
				return $v;
			} else if ($__hx__switch === 1) {
				#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:38: characters 20-21
				$e = $o->params[0];
				#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:38: characters 24-34
				return SinkYielding_Impl_::ofError($e);
			}
		});
		#/Users/ut/haxe/haxe_libraries/tink_io/0.6.2/haxelib/src/tink/io/Sink.hx:36: lines 36-39
		return new FutureSink($ret->gather());
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$BLACKHOLE = Blackhole::$inst;
	}
}

Boot::registerClass(SinkYielding_Impl_::class, 'tink.io._Sink.SinkYielding_Impl_');
SinkYielding_Impl_::__hx__init();
