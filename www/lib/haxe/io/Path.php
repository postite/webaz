<?php
/**
 * Generated by Haxe 4.0.0-rc.2+77068e1
 * Haxe source file: /Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx
 */

namespace haxe\io;

use \php\Boot;
use \php\_Boot\HxString;

/**
 * This class provides a convenient way of working with paths. It supports the
 * common path formats:
 * - `directory1/directory2/filename.extension`
 * - `directory1\directory2\filename.extension`
 */
class Path {
	/**
	 * @var bool
	 * `true` if the last directory separator is a backslash, `false` otherwise.
	 */
	public $backslash;
	/**
	 * @var string
	 * The directory.
	 * This is the leading part of the path that is not part of the file name
	 * and the extension.
	 * Does not end with a `/` or `\` separator.
	 * If the path has no directory, the value is `null`.
	 */
	public $dir;
	/**
	 * @var string
	 * The file extension.
	 * It is separated from the file name by a dot. This dot is not part of
	 * the extension.
	 * If the path has no extension, the value is `null`.
	 */
	public $ext;
	/**
	 * @var string
	 * The file name.
	 * This is the part of the part between the directory and the extension.
	 * If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
	 * is the empty String `""`.
	 */
	public $file;

	/**
	 * Adds a trailing slash to `path`, if it does not have one already.
	 * If the last slash in `path` is a backslash, a backslash is appended to
	 * `path`.
	 * If the last slash in `path` is a slash, or if no slash is found, a slash
	 * is appended to `path`. In particular, this applies to the empty String
	 * `""`.
	 * If `path` is `null`, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function addTrailingSlash ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:265: lines 265-266
		if (mb_strlen($path) === 0) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:266: characters 4-14
			return "/";
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:267: characters 3-34
		$c1 = HxString::lastIndexOf($path, "/");
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:268: characters 3-35
		$c2 = HxString::lastIndexOf($path, "\\");
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:269: lines 269-275
		if ($c1 < $c2) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:270: lines 270-271
			if ($c2 !== (mb_strlen($path) - 1)) {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:270: characters 31-42
				return ($path??'null') . "\\";
			} else {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:271: characters 9-13
				return $path;
			}
		} else if ($c1 !== (mb_strlen($path) - 1)) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:273: characters 31-41
			return ($path??'null') . "/";
		} else {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:274: characters 9-13
			return $path;
		}
	}

	/**
	 * Returns the directory of `path`.
	 * If the directory is `null`, the empty String `""` is returned.
	 * If `path` is `null`, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function directory ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:148: characters 3-26
		$s = new Path($path);
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:149: lines 149-150
		if ($s->dir === null) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:150: characters 4-13
			return "";
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:151: characters 3-15
		return $s->dir;
	}

	/**
	 * Returns the extension of `path`.
	 * If `path` has no extension, the empty String `""` is returned.
	 * If `path` is `null`, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function extension ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:162: characters 3-26
		$s = new Path($path);
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:163: lines 163-164
		if ($s->ext === null) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:164: characters 4-13
			return "";
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:165: characters 3-15
		return $s->ext;
	}

	/**
	 * Returns `true` if the path is an absolute path, and `false` otherwise.
	 * 
	 * @param string $path
	 * 
	 * @return bool
	 */
	static public function isAbsolute ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:304: characters 3-53
		if (\StringTools::startsWith($path, "/")) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:304: characters 42-53
			return true;
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:305: characters 3-41
		if (mb_substr($path, 1, 1) === ":") {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:305: characters 30-41
			return true;
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:306: characters 3-56
		if (\StringTools::startsWith($path, "\\\\")) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:306: characters 45-56
			return true;
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:307: characters 3-15
		return false;
	}

	/**
	 * Joins all paths in `paths` together.
	 * If `paths` is empty, the empty String `""` is returned. Otherwise the
	 * paths are joined with a slash between them.
	 * If `paths` is `null`, the result is unspecified.
	 * 
	 * @param \Array_hx $paths
	 * 
	 * @return string
	 */
	static public function join ($paths) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:190: characters 15-68
		$f = function ($s) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:190: characters 47-67
			if ($s !== null) {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:190: characters 60-67
				return $s !== "";
			} else {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:190: characters 47-67
				return false;
			}
		};
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:190: characters 15-68
		$result = [];
		$collection = $paths->arr;
		foreach ($collection as $key => $value) {
			if ($f($value)) {
				$result[] = $value;
			}
		}

		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:190: characters 3-69
		$paths1 = \Array_hx::wrap($result);
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:191: lines 191-193
		if ($paths1->length === 0) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:192: characters 4-13
			return "";
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:194: characters 3-23
		$path = ($paths1->arr[0] ?? null);
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:195: lines 195-198
		$_g = 1;
		$_g1 = $paths1->length;
		while ($_g < $_g1) {
			$i = $_g++;
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:196: characters 4-33
			$path = Path::addTrailingSlash($path);
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:197: characters 4-20
			$path = ($path??'null') . (($paths1->arr[$i] ?? null)??'null');
		}

		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:199: characters 3-25
		return Path::normalize($path);
	}

	/**
	 * Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).
	 * Also replaces backslashes `\` with slashes `/` and afterwards turns
	 * multiple slashes into a single one.
	 * If `path` is `null`, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function normalize ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:212: characters 3-38
		$path = HxString::split($path, "\\")->join("/");
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:213: characters 3-34
		if ($path === "/") {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:213: characters 22-34
			return "/";
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:215: characters 3-19
		$target = new \Array_hx();
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:217: lines 217-227
		$_g = 0;
		$_g1 = HxString::split($path, "/");
		while ($_g < $_g1->length) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:217: characters 8-13
			$token = ($_g1->arr[$_g] ?? null);
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:217: lines 217-227
			++$_g;
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:218: lines 218-226
			if (($token === "..") && ($target->length > 0) && (($target->arr[$target->length - 1] ?? null) !== "..")) {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:219: characters 5-17
				if ($target->length > 0) {
					$target->length--;
				}
				array_pop($target->arr);
			} else if ($token === "") {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:221: lines 221-223
				if (($target->length > 0) || (HxString::charCodeAt($path, 0) === 47)) {
					#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:222: characters 6-24
					$target->arr[$target->length] = $token;
					++$target->length;
				}
			} else if ($token !== ".") {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:225: characters 5-23
				$target->arr[$target->length] = $token;
				++$target->length;
			}
		}

		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:229: characters 3-32
		$tmp = $target->join("/");
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:230: characters 3-29
		$acc = new \StringBuf();
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:231: characters 3-21
		$colon = false;
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:232: characters 3-23
		$slashes = false;
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:233: lines 233-248
		$_g2 = 0;
		$_g3 = mb_strlen($tmp);
		while ($_g2 < $_g3) {
			$i = $_g2++;
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:234: characters 12-42
			$_g21 = \StringTools::fastCodeAt($tmp, $i);
			if ($_g21 === 47) {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:238: lines 238-246
				if (!$colon) {
					#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:239: characters 6-20
					$slashes = true;
				} else {
					#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:241: characters 6-19
					$colon = false;
					#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:242: lines 242-245
					if ($slashes) {
						#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:243: characters 7-19
						$acc->add("/");
						#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:244: characters 7-22
						$slashes = false;
					}
					#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:246: characters 6-20
					$acc->b = ($acc->b??'null') . (mb_chr($_g21)??'null');
				}
			} else if ($_g21 === 58) {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:236: characters 6-18
				$acc->add(":");
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:237: characters 6-18
				$colon = true;
			} else {
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:241: characters 6-19
				$colon = false;
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:242: lines 242-245
				if ($slashes) {
					#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:243: characters 7-19
					$acc->add("/");
					#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:244: characters 7-22
					$slashes = false;
				}
				#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:246: characters 6-20
				$acc->b = ($acc->b??'null') . (mb_chr($_g21)??'null');
			}

		}

		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:249: characters 3-24
		return $acc->b;
	}

	/**
	 * Returns the String representation of `path` without the directory.
	 * If `path` is `null`, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function withoutDirectory ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:135: characters 3-26
		$s = new Path($path);
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:136: characters 3-15
		$s->dir = null;
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:137: characters 3-22
		return $s->toString();
	}

	/**
	 * Returns the String representation of `path` without the file extension.
	 * If `path` is `null`, the result is unspecified.
	 * 
	 * @param string $path
	 * 
	 * @return string
	 */
	static public function withoutExtension ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:124: characters 3-26
		$s = new Path($path);
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:125: characters 3-15
		$s->ext = null;
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:126: characters 3-22
		return $s->toString();
	}

	/**
	 * Creates a new `Path` instance by parsing `path`.
	 * Path information can be retrieved by accessing the `dir`, `file` and `ext`
	 * properties.
	 * 
	 * @param string $path
	 * 
	 * @return void
	 */
	public function __construct ($path) {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:77: lines 77-82
		if ($path === "." || $path === "..") {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:79: characters 5-15
			$this->dir = $path;
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:80: characters 5-14
			$this->file = "";
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:81: characters 5-11
			return;
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:83: characters 3-34
		$c1 = HxString::lastIndexOf($path, "/");
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:84: characters 3-35
		$c2 = HxString::lastIndexOf($path, "\\");
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:85: lines 85-93
		if ($c1 < $c2) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:86: characters 4-27
			$this->dir = mb_substr($path, 0, $c2);
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:87: characters 4-28
			$path = mb_substr($path, $c2 + 1, null);
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:88: characters 4-20
			$this->backslash = true;
		} else if ($c2 < $c1) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:90: characters 4-27
			$this->dir = mb_substr($path, 0, $c1);
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:91: characters 4-28
			$path = mb_substr($path, $c1 + 1, null);
		} else {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:93: characters 4-14
			$this->dir = null;
		}
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:94: characters 3-34
		$cp = HxString::lastIndexOf($path, ".");
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:95: lines 95-101
		if ($cp !== -1) {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:96: characters 4-27
			$this->ext = mb_substr($path, $cp + 1, null);
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:97: characters 4-28
			$this->file = mb_substr($path, 0, $cp);
		} else {
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:99: characters 4-14
			$this->ext = null;
			#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:100: characters 4-15
			$this->file = $path;
		}
	}

	/**
	 * Returns a String representation of `this` path.
	 * If `this.backslash` is `true`, backslash is used as directory separator,
	 * otherwise slash is used. This only affects the separator between
	 * `this.dir` and `this.file`.
	 * If `this.directory` or `this.extension` is `null`, their representation
	 * is the empty String `""`.
	 * 
	 * @return string
	 */
	public function toString () {
		#/Users/ut/haxe/versions/4.0.0-rc.2/std/haxe/io/Path.hx:115: characters 3-120
		return ((($this->dir === null ? "" : ($this->dir??'null') . ((($this->backslash ? "\\" : "/"))??'null')))??'null') . ($this->file??'null') . ((($this->ext === null ? "" : "." . ($this->ext??'null')))??'null');
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(Path::class, 'haxe.io.Path');
